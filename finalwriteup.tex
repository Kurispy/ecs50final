\documentclass[11pt]{article}

\setlength{\oddsidemargin}{0.0in}
\setlength{\evensidemargin}{0.0in}
\setlength{\topmargin}{-0.25in}
\setlength{\headheight}{0in}
\setlength{\headsep}{0in}
\setlength{\textwidth}{6.5in}
\setlength{\textheight}{9.25in}
\setlength{\parindent}{0in}
\setlength{\parskip}{2mm}

\begin{document}

In order to simplify both the writing and reading of this document, we have to decided to call the optimized version of Primes.c ``Primes$_{O}$'' and the unoptimized version of Primes.c ``Primes$_{U}$''.

1. There is no function prologue and epilogue in the optimized code. (In worker and crossout)

One of the easiest differences to spot between Primes$_{O}$ and Primes$_{U}$ is the lack of function prologues and epilogues that are present in the ``crossout" and ``worker" subroutines of Primes$_{U}$. It can also be noted that due to this, all values on the stack are referenced directly through \%esp in Primes$_{O}$ instead of through \%ebp like in Primes$_{U}$.

This optimization removes one PUSH, one POP, and two MOV operations per subroutine call, which can save a good amount of time if there are many subroutine calls. However this comes at the cost of increased compile time, as the compiler must determine the location of each value on the stack every time the stack pointer is modified. (This does not have to be done when the frame pointer is used to reference values, since it does not change for the duration of the subroutine.) It can also cause problems when debugging, since it eliminates the ability to backtrace. 

2. The optimized code uses leal on line 83-89, while the nonop code uses addl in line 75-83


Another difference between Primes$_{U}$ and Primes$_{O}$ is that Primes$_{O}$ uses leal to compute an address as opposed to the former which uses a combination of addl and movl. 

\begin{verbatim}
Optimized Code
.L14:
    movl	 $nextbaselock, (%esp)
    call	 pthread_mutex_lock
    movl	 nextbase, %ebx
    leal	 2(%ebx), %edx
    movl	 %edx, nextbase
    movl	 $nextbaselock, (%esp)
    call	 pthread_mutex_unlock
	
Non Optimized Code
.L8:
    movl	 $nextbaselock, (%esp)
    call	 pthread_mutex_lock
    movl	 nextbase, %eax         
    movl	 %eax, -12(%ebp)        
    movl	 nextbase, %eax         
    addl	 $2, %eax
    movl	 %eax, nextbase
    movl	 $nextbaselock, (%esp)
    call pthread_mutex_unlock
\end{verbatim}

There are many benefits to use leal over addl/movl. First of all, the leal instruction does not set any flags as opposed to addl which will set OF, SF, ZF, AF, PF, CF. When an arithmetic instruction is used, such as add, this instruction will be processed by the arithmetic and logic unit (ALU) which then outputs a result. Each time the ALU is used, the flag register is immediately updated to correspond with the result from the ALU. On the other hand, the leal instruction gets its address from the Address Generation Unit (AGU) right as the instruction is executed. This is done by a technique called "instruction pipeline". This reduces the overhead of going through the ALU and updating the flag register thus increasing performance.

3. The optimized code uses more efficient addressing modes. (line 125-126 non op vs line 140 op code and line 131-132 non op vs line 144 op code)

Primes$_{O}$ uses a more efficient addressing mode than Primes$_{U}$. A well known issue in assembly language is that a user is not allowed to have memory to memory access in a single line. In our Primes program, there are several instances where we must get the next element in a register and have it stored in a different register. A sample of the addressing mode in Primes$_{U}$(line 125-126) looks like:


\hspace*{2.2in} addl \$4, \%eax \\

\hspace*{2.2in} movl (\%eax), \%eax 


Although there isn't a significant amount of time spent doing addition between two registers, it is an extra computation that must be executed every time, hence time that is wasted. On the other hand a more efficient method is seen with the addressing mode used in Primes$_{O}$(line 140) which looks like: 


\hspace*{2.2in} movl 4(\%ebx), \%eax


Here we automatically get the next element in register ebx and store it into register eax without the need of incrementing the pointer of the current register and then storing the contents of the incremented register to another register.

%---------------PART 2 OF PART 2 BEGINS HERE----------------

%1st Statement

%Second Statement

Our second ``compilation" of code is an if statement that begins on line 63 in Primes.c:
\begin{verbatim}
//Function call with parameter
   crossout(base);
\end{verbatim}

Here is the ``compiled" code in MIPS.

\begin{verbatim}
MIPS "compiled" code:
   la $2, base
   lw $4, 0($2)
   la $25, crossout
   jal $31, $25
\end{verbatim}

The code above is used to pass arguments into a function and then calls the function. Here is how it works. 

\begin{verbatim}
   la $2, base
   lw $4, 0($2)
\end{verbatim}

The {\bf la} instruction (Load Address) puts the address of base into register \$2. The {\bf lw} instruction (Load Word), which uses based addressing, adds 0 to the address within register \$2 and stores the content within that address into \$4. We use register \$4 as the suggested register for passing arguments.

\begin{verbatim}
   la $25, crossout
   jal $31, $25
\end{verbatim}

We use {\bf la} in a similar fashion as above. It gets the address of our function crossout and stores it in register \$25. We then call crossout by using its address which we saved earlier in register \$25. The {\bf jal} instruction does just this. It is called {\bf jump and link}, which means we will jump to the subroutine pointed to by \$25 and save the return address in \$31. Again, we use register \$31 to follow RISC philosophy of orthogonality, we could have used any free registers if we wanted.

Note that our instructions above {\bf la and lw} are not actual instruction implemented into the hardware. They are actually a feature of MIPS called {\bf pseudoinstruction}. Consider 

\begin{verbatim}
   la $2, base
\end{verbatim}

One issue here is that {\bf base} is a 32-bit address and each MIPS instruction are also 32-bit. This gives us no room to store the address AND the instruction. So {\bf la} will break up the address into smaller bit sections and store them in register \$2. This requires a few extra instructions but is done for us by pseudoinstruction. Another issue is that we need to let the assembler know that we want to get the address of base and not the value, {\bf la} will also take care of that.



%3rd Statement
Our third and final ``compilation" of code is an if statement that begins on line 104 in Primes.c:

\begin{verbatim}
if (prime[i]) {
     nprimes++;
}
\end{verbatim}

We'll start off by presenting the entirety of the MIPS assembly code, and then work though it line by line. (We have assumed that the address of the first element of the ``prime" array is in the register \$s0, the index ``i" is in the register \$s1, and $nprimes$ is in \$s4.)

\begin{verbatim}
sll $s2, $s1, 2
ori $s3, $s0, 0
addu $s3, $s3, $s2
lw $s3, $s3
beq $s3, $0, .L1
addiu $s1, $s1, 1
addiu $s4, $s4, 1
\end{verbatim}

Now let's look at the first chunk of code:

\begin{verbatim}
sll $s2, $s1, 2
ori $s3, $s0, 0
addiu $s3, $s3, $s2
lw $s3, $s3
\end{verbatim}

The first line multiplies the index by 4 and places it in a new register, effectually converting the index from an integer-sized offset to a byte-sized offset. (The reason we place the converted index in a new register is to preserve the unmodified index for later comparisons and modifications that are outside the scope of this statement.) With the next $ori$ instruction we move the address of the first element of the $prime$ array (or just $prime$) into register \$s3, as \$s3 will eventually hold our accessed element of $prime$. The addiu instruction then adds the offset held in \$s2 to $prime$, and puts it back in \$s3. \$s3 now holds the address of the element in $prime$ that we want to access. Finally, the lw instruction takes the word pointed to in the \$s3 register and stores it in \$s3. (Essentially a dereference of \$s3.) We now have everything we need to do our $if$ statement. Let's continue on to the next segment of code:

\begin{verbatim}
beq $s3, $0, .L1
addiu $s1, $s1, 1
addiu $s4, $s4, 1
\end{verbatim}

Now that we have our desired operand for the $if$ statment stored in \$s3, we compare it to zero with the beq instruction. This takes advantage of the fact that \$0 will always contain the constant 0. If we had used a different register to perform the comparison we would have had to zero it out first in order to make sure it was 0. If \$s3 is not zero, we will fall through to the $nprimes++$ statement inside the $if$. If \$s3 is zero, we jump to another location that is outside the scop of this statement. 

By now you may have noticed that the line

\begin{verbatim}
addiu $s1, $s1, 1
\end{verbatim}

does not actually correspond to the $nprimes++$ statement. What it actually corresponds to is the statement $i++$. This instruction is specifically placed here so as to fill a delay slot produced by the preceding $beq$ instruction, thereby increasing the efficiency of the code. It can be placed here because $i$ will be incremented regardless of whether we branch or not. Our last instruction is an $addiu$ that will only be executed if the $beq$ instruction did not branch. It is equivalent to the $nprimes++$ statement.



\end{document}  % required; the document ends here
