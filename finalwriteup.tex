\documentclass[11pt]{article}

\setlength{\oddsidemargin}{0.0in}
\setlength{\evensidemargin}{0.0in}
\setlength{\topmargin}{-0.25in}
\setlength{\headheight}{0in}
\setlength{\headsep}{0in}
\setlength{\textwidth}{6.5in}
\setlength{\textheight}{9.25in}
\setlength{\parindent}{0in}
\setlength{\parskip}{2mm}

\begin{document}

In order to simplify both the writing and reading of this document, we have to decided to call the optimized version of Primes.c ``Primes$_{O}$'' and the unoptimized version of Primes.c ``Primes$_{U}$''.

1. There is no function prologue and epilogue in the optimized code. (In worker and crossout)

One of the easiest differences to spot between Primes$_{O}$ and Primes$_{U}$ is the lack of function prologues and epilogues that are present in the ``crossout" and ``worker" subroutines of Primes$_{U}$. It can also be noted that due to this, all values on the stack are referenced directly through \%esp in Primes$_{O}$ instead of through \%ebp like in Primes$_{U}$.

This optimization removes one PUSH, one POP, and two MOV operations per subroutine call, which can save a good amount of time if there are many subroutine calls. However this comes at the cost of increased compile time, as the compiler must determine the location of each value on the stack every time the stack pointer is modified. (This does not have to be done when the frame pointer is used to reference values, since it does not change for the duration of the subroutine.) It can also cause problems when debugging, since it eliminates the ability to backtrace. 

2. The optimized code uses leal on line 83-89, while the nonop code uses addl in line 75-83


Another difference between Primes$_{U}$ and Primes$_{O}$ is that Primes$_{O}$ uses leal to compute an address as opposed to the former which uses a combination of addl and movl. 

\begin{verbatim}
Optimized Code
.L14:
    movl	 $nextbaselock, (%esp)
    call	 pthread_mutex_lock
    movl	 nextbase, %ebx
    leal	 2(%ebx), %edx
    movl	 %edx, nextbase
    movl	 $nextbaselock, (%esp)
    call	 pthread_mutex_unlock
	
Non Optimized Code
.L8:
    movl	 $nextbaselock, (%esp)
    call	 pthread_mutex_lock
    movl	 nextbase, %eax         
    movl	 %eax, -12(%ebp)        
    movl	 nextbase, %eax         
    addl	 $2, %eax
    movl	 %eax, nextbase
    movl	 $nextbaselock, (%esp)
    call pthread_mutex_unlock
\end{verbatim}

There are many benefits to use leal over addl/movl. First of all, the leal instruction does not set any flags as opposed to addl which will set OF, SF, ZF, AF, PF, CF. When an arithmetic instruction is used, such as add, this instruction will be processed by the arithmetic and logic unit (ALU) which then outputs a result. Each time the ALU is used, the flag register is immediately updated to correspond with the result from the ALU. On the other hand, the leal instruction gets its address from the Address Generation Unit (AGU) right as the instruction is executed. This is done by a technique called "instruction pipeline". This reduces the overhead of going through the ALU and updating the flag register thus increasing performance.

3. The optimized code uses more efficient addressing modes. (line 125-126 non op vs line 140 op code and line 131-132 non op vs line 144 op code)

Primes$_{O}$ uses a more efficient addressing mode than Primes$_{U}$. A well known issue in assembly language is that a user is not allowed to have memory to memory access in a single line. In our Primes program, there are several instances where we must get the next element in a register and have it stored in a different register. A sample of the addressing mode in Primes$_{U}$(line 125-126) looks like:


\hspace*{2.2in} addl \$4, \%eax \\

\hspace*{2.2in} movl (\%eax), \%eax 


Although there isn't a significant amount of time spent doing addition between two registers, it is an extra computation that must be executed every time, hence time that is wasted. On the other hand a more efficient method is seen with the addressing mode used in Primes$_{O}$(line 140) which looks like: 


\hspace*{2.2in} movl 4(\%ebx), \%eax


Here we automatically get the next element in register ebx and store it into register eax without the need of incrementing the pointer of the current register and then storing the contents of the incremented register to another register.

% the $ delimiter marks the start and end of a mathematical expression

\begin{equation}
\theta = cos^{-1}(\frac{x}{z})  % note the need for braces around the -1
\end{equation}

% the parentheses in the above expression aren't quite big enough;
% instead, we could have the LaTeX code
% \begin{equation}
% \theta = cos^{-1} \left ( \frac{x}{z} \right)  
% \end{equation}
% try it yourself (don't forget to remove the % comment symbols first)

\end{document}  % required; the document ends here
